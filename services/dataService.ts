\nimport { Dish, WeeklyPlan, Ingredient } from \'../types\';\nimport { DISH_CATEGORIES, MOCK_DISHES } from \'../constants\';\nimport { supabase } from \'../lib/supabase\';\n\nconsole.log(\"Initializing dataService (Supabase)...\");\n\nconst LS_KEYS = {\n  DISHES: \'mygourmet_dishes\',\n  PLANS: \'mygourmet_plans\',\n  CATEGORIES: \'mygourmet_categories\'\n};\n\n// In-Memory Fallback store in case LocalStorage is disabled/throws\nconst memoryStore: Record<string, any> = {};\n\n// Safe LocalStorage Wrapper\nconst safeStorage = {\n  getItem: (key: string): string | null => {\n    try {\n      return localStorage.getItem(key);\n    } catch (e) {\n      console.warn(\"LocalStorage access denied, using memory store\");\n      return memoryStore[key] || null;\n    }\n  },\n  setItem: (key: string, value: string): void => {\n    try {\n      localStorage.setItem(key, value);\n    } catch (e) {\n      memoryStore[key] = value;\n    }\n  }\n};\n\n// Polyfill for randomUUID\nexport const generateId = (): string => {\n  if (typeof crypto !== \'undefined\' && crypto.randomUUID) {\n    try {\n      return crypto.randomUUID();\n    } catch (e) { }\n  }\n  return \'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\'.replace(/[xy]/g, function (c) {\n    const r = Math.random() * 16 | 0, v = c === \'x\' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n};\n\n// State to track if we are forcing local storage due to API failure\nlet useLocalStorage = false;\n\n// Helper to initialize LocalStorage with Mock data if empty\nconst initLocalStorage = () => {\n  try {\n    if (!safeStorage.getItem(LS_KEYS.DISHES)) {\n      safeStorage.setItem(LS_KEYS.DISHES, JSON.stringify(MOCK_DISHES));\n    }\n    if (!safeStorage.getItem(LS_KEYS.PLANS)) {\n      safeStorage.setItem(LS_KEYS.PLANS, JSON.stringify([]));\n    }\n    if (!safeStorage.getItem(LS_KEYS.CATEGORIES)) {\n      safeStorage.setItem(LS_KEYS.CATEGORIES, JSON.stringify(DISH_CATEGORIES));\n    }\n  } catch (e) {\n    console.error(\"Failed to init storage\", e);\n  }\n};\n\n// Initialize once\ninitLocalStorage();\n\n// Helper for Local Storage Operations\nconst localStore = {\n  get: <T>(key: string): T => {\n    try {\n      const item = safeStorage.getItem(key);\n      return item ? JSON.parse(item) : [];\n    } catch (e) {\n      console.error(\"Error parsing local data\", e);\n      return [] as unknown as T;\n    }\n  },\n  set: (key: string, data: any) => {\n    try {\n      safeStorage.setItem(key, JSON.stringify(data));\n    } catch (e) {\n      console.error(\"Error saving local data\", e);\n    }\n  }\n};\n\n// DB to App mapping\nconst mapDishFromDb = (d: any): Dish => ({\n  id: d.id,\n  name: d.name,\n  image: d.image,\n  rating: d.rating,\n  recipeLink: d.recipelink,\n  notes: d.notes,\n  timesCooked: d.timescooked,\n  lastCooked: d.lastcooked,\n  ingredients: d.ingredients || [],\n  tags: d.dish_tags ? d.dish_tags.map((t: any) => t.tagname) : []\n});\n\nexport const dataService = {\n  checkBackendConnection: async (): Promise<boolean> => {\n    try {\n      useLocalStorage = false;\n      const { error } = await supabase.from(\'mygourmet_categories\').select(\'count\', { count: \'exact\', head: true });\n      if (error) throw error;\n      return true;\n    } catch (e) {\n      console.warn(\"Supabase connection check failed, switching to local storage\", e);\n      useLocalStorage = true;\n      return false;\n    }\n  },\n\n  getDishes: async (): Promise<Dish[]> => {\n    if (useLocalStorage) return localStore.get<Dish[]>(LS_KEYS.DISHES);\n\n    try {\n      const { data, error } = await supabase\n        .from(\'mygourmet_dishes\')\n        .select(`\n          *,\n          ingredients:mygourmet_ingredients (*),\n          dish_tags:mygourmet_dish_tags (tagname)\n        `);\n\n      if (error) throw error;\n      return (data || []).map(mapDishFromDb);\n    } catch (e) {\n      console.error(\"Failed to fetch dishes from Supabase\", e);\n      useLocalStorage = true;\n      return localStore.get<Dish[]>(LS_KEYS.DISHES);\n    }\n  },\n\n  addDish: async (dish: Omit<Dish, \'id\'>): Promise<Dish> => {\n    const newDish = { ...dish, id: generateId() };\n\n    if (useLocalStorage) {\n      const dishes = localStore.get<Dish[]>(LS_KEYS.DISHES);\n      dishes.unshift(newDish as Dish);\n      localStore.set(LS_KEYS.DISHES, dishes);\n      return newDish as Dish;\n    }\n\n    try {\n      const { error: dishError } = await supabase\n        .from(\'mygourmet_dishes\')\n        .insert([{\n          id: newDish.id,\n          name: newDish.name,\n          image: newDish.image,\n          rating: newDish.rating,\n          recipelink: newDish.recipeLink,\n          notes: newDish.notes,\n          timescooked: newDish.timesCooked,\n          lastcooked: newDish.lastCooked\n        }]);\n\n      if (dishError) throw dishError;\n\n      if (newDish.ingredients.length > 0) {\n        const ingredientsToInsert = newDish.ingredients.map(ing => ({\n          dishid: newDish.id,\n          name: ing.name,\n          amount: ing.amount,\n          unit: ing.unit\n        }));\n        const { error: ingError } = await supabase.from(\'mygourmet_ingredients\').insert(ingredientsToInsert);\n        if (ingError) throw ingError;\n      }\n\n      if (newDish.tags && newDish.tags.length > 0) {\n        const tagsToInsert = newDish.tags.map(tag => ({\n          dishid: newDish.id,\n          tagname: tag\n        }));\n        const { error: tagError } = await supabase.from(\'mygourmet_dish_tags\').insert(tagsToInsert);\n        if (tagError) throw tagError;\n      }\n\n      return newDish as Dish;\n    } catch (e) {\n      console.error(\"Failed to add dish to Supabase\", e);\n      useLocalStorage = true;\n      const dishes = localStore.get<Dish[]>(LS_KEYS.DISHES);\n      dishes.unshift(newDish as Dish);\n      localStore.set(LS_KEYS.DISHES, dishes);\n      return newDish as Dish;\n    }\n  },\n\n  updateDish: async (dish: Dish): Promise<Dish> => {\n    if (useLocalStorage) {\n      const dishes = localStore.get<Dish[]>(LS_KEYS.DISHES);\n      const index = dishes.findIndex(d => d.id === dish.id);\n      if (index !== -1) {\n        dishes[index] = dish;\n        localStore.set(LS_KEYS.DISHES, dishes);\n      }\n      return dish;\n    }\n\n    try {\n      const { error: dishError } = await supabase\n        .from(\'mygourmet_dishes\')\n        .update({\n          name: dish.name,\n          image: dish.image,\n          rating: dish.rating,\n          recipelink: dish.recipeLink,\n          notes: dish.notes,\n          timescooked: dish.timesCooked,\n          lastcooked: dish.lastCooked\n        })\n        .eq(\'id\', dish.id);\n\n      if (dishError) throw dishError;\n\n      await supabase.from(\'mygourmet_ingredients\').delete().eq(\'dishid\', dish.id);\n      if (dish.ingredients.length > 0) {\n        const ingredientsToInsert = dish.ingredients.map(ing => ({\n          dishid: dish.id,\n          name: ing.name,\n          amount: ing.amount,\n          unit: ing.unit\n        }));\n        await supabase.from(\'mygourmet_ingredients\').insert(ingredientsToInsert);\n      }\n\n      await supabase.from(\'mygourmet_dish_tags\').delete().eq(\'dishid\', dish.id);\n      if (dish.tags && dish.tags.length > 0) {\n        const tagsToInsert = dish.tags.map(tag => ({\n          dishid: dish.id,\n          tagname: tag\n        }));\n        await supabase.from(\'mygourmet_dish_tags\').insert(tagsToInsert);\n      }\n\n      return dish;\n    } catch (e) {\n      console.error(\"Failed to update dish in Supabase\", e);\n      useLocalStorage = true;\n      const dishes = localStore.get<Dish[]>(LS_KEYS.DISHES);\n      const index = dishes.findIndex(d => d.id === dish.id);\n      if (index !== -1) {\n        dishes[index] = dish;\n        localStore.set(LS_KEYS.DISHES, dishes);\n      }\n      return dish;\n    }\n  },\n  \n  updateDishCookingStats: async (dishId: string, increment: boolean): Promise<void> => {\n    try {\n      const dishes = await dataService.getDishes();\n      const dish = dishes.find(d => d.id === dishId);\n      if (!dish) return;\n\n      const updatedDish: Dish = {\n        ...dish,\n        timesCooked: Math.max(0, (dish.timesCooked || 0) + (increment ? 1 : -1)),\n        lastCooked: increment ? new Date().toISOString() : dish.lastCooked\n      };\n\n      await dataService.updateDish(updatedDish);\n    } catch (error) {\n      console.error(\'Failed to update dish cooking stats:\', error);\n    }\n  },\n\n  deleteDish: async (id: string): Promise<void> => {\n    if (useLocalStorage) {\n      const dishes = localStore.get<Dish[]>(LS_KEYS.DISHES);\n      const filtered = dishes.filter(d => d.id !== id);\n      localStore.set(LS_KEYS.DISHES, filtered);\n      return;\n    }\n\n    try {\n      const { error } = await supabase.from(\'mygourmet_dishes\').delete().eq(\'id\', id);\n      if (error) throw error;\n    } catch (e) {\n      console.error(\"Failed to delete dish\", e);\n      useLocalStorage = true;\n      const dishes = localStore.get<Dish[]>(LS_KEYS.DISHES);\n      const filtered = dishes.filter(d => d.id !== id);\n      localStore.set(LS_KEYS.DISHES, filtered);\n    }\n  },\n\n  getPlans: async (): Promise<WeeklyPlan[]> => {\n    if (useLocalStorage) return localStore.get<WeeklyPlan[]>(LS_KEYS.PLANS);\n\n    try {\n      const { data, error } = await supabase.from(\'mygourmet_menu_plans\').select(\'*\');\n      if (error) throw error;\n\n      const plansMap = new Map<string, WeeklyPlan>();\n      (data || []).forEach((row: any) => {\n        const id = `${row.year}-${row.week}`;\n        if (!plansMap.has(id)) {\n          plansMap.set(id, { id, year: row.year, week: row.week, dishIds: [] });\n        }\n        if (row.dishid) {\n          plansMap.get(id)!.dishIds.push(row.dishid);\n        }\n      });\n      return Array.from(plansMap.values());\n    } catch (e) {\n      console.error(\"Failed to get plans\", e);\n      useLocalStorage = true;\n      return localStore.get<WeeklyPlan[]>(LS_KEYS.PLANS);\n    }\n  },\n\n  addDishToPlan: async (year: number, week: number, dishId: string): Promise<void> => {\n    if (useLocalStorage) {\n      const plans = localStore.get<WeeklyPlan[]>(LS_KEYS.PLANS);\n      const id = `${year}-${week}`;\n      let plan = plans.find(p => p.id === id || (p.year === year && p.week === week));\n      if (!plan) {\n        plan = { id, year, week, dishIds: [] };\n        plans.push(plan);\n      }\n      if (!plan.dishIds.includes(dishId)) {\n        plan.dishIds.push(dishId);\n      }\n      localStore.set(LS_KEYS.PLANS, plans);\n      await dataService.updateDishCookingStats(dishId, true);\n      return;\n    }\n\n    try {\n      const { error } = await supabase.from(\'mygourmet_menu_plans\').insert([{ year, week, dishid: dishId }]);\n      if (error) throw error;\n      await dataService.updateDishCookingStats(dishId, true);\n    } catch (e) {\n      console.error(\"Failed to add to plan\", e);\n    }\n  },\n\n  removeDishFromPlan: async (year: number, week: number, dishId: string): Promise<void> => {\n    if (useLocalStorage) {\n      const plans = localStore.get<WeeklyPlan[]>(LS_KEYS.PLANS);\n      const plan = plans.find(p => p.year === year && p.week === week);\n      if (plan) {\n        const idx = plan.dishIds.indexOf(dishId);\n        if (idx > -1) {\n          plan.dishIds.splice(idx, 1);\n        }\n        localStore.set(LS_KEYS.PLANS, plans);\n      }\n      await dataService.updateDishCookingStats(dishId, false);\n      return;\n    }\n\n    try {\n      const { error } = await supabase\n        .from(\'mygourmet_menu_plans\')\n        .delete()\n        .match({ year, week, dishid: dishId });\n\n      if (error) throw error;\n      await dataService.updateDishCookingStats(dishId, false);\n    } catch (e) {\n      console.error(\"Failed to remove from plan\", e);\n    }\n  },\n\n  getCategories: async (): Promise<string[]> => {\n    if (useLocalStorage) {\n      const stored = localStore.get<string[]>(LS_KEYS.CATEGORIES);\n      return (stored && stored.length > 0) ? stored : DISH_CATEGORIES;\n    }\n\n    try {\n      const { data, error } = await supabase\n        .from(\'mygourmet_categories\')\n        .select(\'name\')\n        .order(\'sortorder\', { ascending: true });\n\n      if (error) throw error;\n      if (!data || data.length === 0) return DISH_CATEGORIES;\n      return data.map((c: any) => c.name);\n    } catch (e) {\n      console.error(\"Failed to get categories\", e);\n      useLocalStorage = true;\n      const stored = localStore.get<string[]>(LS_KEYS.CATEGORIES);\n      return (stored && stored.length > 0) ? stored : DISH_CATEGORIES;\n    }\n  },\n\n  saveCategories: async (categories: string[]): Promise<void> => {\n    if (useLocalStorage) {\n      localStore.set(LS_KEYS.CATEGORIES, categories);\n      return;\n    }\n\n    try {\n      const rows = categories.map((name, index) => ({\n        name,\n        sortorder: index\n      }));\n\n      const { error } = await supabase.from(\'mygourmet_categories\').upsert(rows, { onConflict: \'name\' });\n      if (error) throw error;\n    } catch (e) {\n      console.error(\"Failed to save categories\", e);\n      useLocalStorage = true;\n      localStore.set(LS_KEYS.CATEGORIES, categories);\n    }\n  },\n\n  getShoppingList: async (year: number, week: number): Promise<Ingredient[]> => {\n    try {\n      let plans = await dataService.getPlans();\n      let dishes = await dataService.getDishes();\n\n      const safePlans = Array.isArray(plans) ? plans : [];\n      const safeDishes = Array.isArray(dishes) ? dishes : [];\n\n      const id = `${year}-${week}`;\n      const plan = safePlans.find((p) => p.id === id || (p.year === year && p.week === week));\n\n      if (!plan) return [];\n\n      const allIngredients: Ingredient[] = [];\n\n      plan.dishIds.forEach(dishId => {\n        const dish = safeDishes.find(d => d.id === dishId);\n        if (dish && dish.ingredients) {\n          allIngredients.push(...dish.ingredients);\n        }\n      });\n\n      return allIngredients;\n    } catch (e) {\n      console.error(\"Shopping list generation failed\", e);\n      return [];\n    }\n  },\n\n  fetchRecipeData: async (url: string): Promise<any> => {\n    if (!url) {\n      return { success: false, error: \"URL is required.\" };\n    }\n\n    // Remove protocol from the target URL to prevent nginx slash-merging issues.\n    const targetUrl = url.replace(/^(https?:\/\/)/, \'\');\n    const proxyUrl = `https://cors.bivort.de/${targetUrl}`;\n\n    try {\n      const response = await fetch(proxyUrl, {\n         headers: {\n           \'X-Requested-With\': \'XMLHttpRequest\',\n           \'Origin\': \'https://mygourmet.bivort.de\'\n         }\n      });\n\n      if (response.status === 403) {\n        return { success: false, error: \"Zugriff verweigert (403). Die Ziel-Webseite (z.B. Chefkoch.de) blockiert möglicherweise die Anfrage des Proxy-Servers. Versuche es später erneut oder trage die Daten manuell ein.\" };\n      }\n      if (!response.ok) {\n        throw new Error(`Proxy-Anfrage fehlgeschlagen mit Status: ${response.status}`);\n      }\n\n      const html = await response.text();\n      const parser = new DOMParser();\n      const doc = parser.parseFromString(html, \'text/html\');\n      \n      // --- Scrape Data (Chefkoch specific) ---\n\n      const name = doc.querySelector(\'h1.page-title, .page-title\')?.textContent?.trim() || \'\';\n      if (!name) console.warn(\"Rezept-Name konnte nicht im HTML gefunden werden.\");\n\n      const ingredients: Ingredient[] = [];\n      const ingredientRows = doc.querySelectorAll(\'.ingredients tr, table[class*=\"ingredients\"] tr\');\n      ingredientRows.forEach(row => {\n          const amountCell = row.querySelector(\'td:first-child\');\n          const nameCell = row.querySelector(\'td:nth-child(2)\');\n          \n          if (amountCell && nameCell) {\n              const amountText = amountCell.textContent?.trim().replace(/\\s*\\n\\s*/g, \' \').trim() || \'\';\n              const nameText = nameCell.textContent?.trim() || \'\';\n\n              if (nameText) {\n                  const match = amountText.match(/^([\\d.,\\/\\s-–]+(?:[\\d.,\\/\\s-–]+)*)?\\s*(.*)$/);\n                  let amount = match?.[1]?.trim() || \'\';\n                  let unit = match?.[2]?.trim() || \'\';\n\n                  if (!amount && unit) {\n                      // This case is for things like \"Etwas\" or \"n. B.\"\n                  } else if (amount && !unit) {\n                      const parts = amount.split(/\\s+/);\n                      if (parts.length > 1 && isNaN(parseFloat(parts[parts.length-1]))) {\n                          unit = parts.pop() + (unit ? ` ${unit}` : \'\');\n                          amount = parts.join(\' \');\n                      }\n                  }\n\n                  ingredients.push({\n                      id: generateId(),\n                      amount: amount,\n                      unit: unit,\n                      name: nameText\n                  });\n              }\n          }\n      });\n      if (ingredients.length === 0) console.warn(\"Zutaten konnten nicht im HTML gefunden werden.\");\n\n      const instructionsDiv = doc.querySelector(\'#rezept-zubereitung, [class*=\"instructions\"]\');\n      const notes = instructionsDiv?.innerText?.trim() || \'\';\n      if (!notes) console.warn(\"Zubereitungsschritte konnten nicht im HTML gefunden werden.\");\n\n      return {\n        success: true,\n        name: name,\n        ingredients: ingredients,\n        notes: notes\n      };\n\n    } catch (e) {\n      console.error(`Fehler beim Laden über den Proxy ${proxyUrl}`, e);\n      return { success: false, error: `Dein Proxy-Server unter ${proxyUrl} ist nicht erreichbar oder funktioniert nicht wie erwartet. Details: ${(e as Error).message}` };\n    }\n  }\n};\n